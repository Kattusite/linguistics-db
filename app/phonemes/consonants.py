from . import ipa_json, utils

# Canonical Consonant Order v2.0
# Be sure to check carefully before & after changing this list, as it may have
# unintended consequences, and is used throughout the program in various places
# as the authoritative, canonical list of phonemes.
# (i.e. something will break if you aren't careful)

# (Some) Areas this list affects:
# Generating the clickable phoneme selector GUI elements
# Checking for phoneme membership in language.py

# IPA row headers (specifies the ordering)
# Note this list excludes things like liquids / glides (from v1.0)
# And excludes things like rhotics that were not in any prev. version
# Note that this list is ONLY used for the ordering of IPA charts, and
# metaclass selectors (ipacbox/clbox in allgen.py)
# It is NOT the canonical list of all possible values - see the DICTs below for those
MANNERS = [
    "plosive",
    "aspirated",
    "nasal",
    "trill",
    "tap or flap",
    "fricative",
    "affricate",
    "lateral fricative",
    "approximant",
    "lateral approximant"
]

# IPA col headers (specifies the ordering)
PLACES = [
    "bilabial",
    "labiodental",
    "dental",
    "alveolar",
    "postalveolar",
    "retroflex",
    "palatal",
    "velar",
    "uvular",
    "pharyngeal",
    "glottal"
]

# Specifies left/right ordering of voiced/unvoiced phoneme pairs
VOICINGS = [
    "voiceless",
    "voiced"
]

HEADERS = {
    "manner":  MANNERS,
    "place":   PLACES,
    "voicing": VOICINGS,

    # In what order should they be arranged when used to write out phonemes
    # e.g. voiceless bilabial fricative NOT fricative voiced bilabial
    "word order":  ["voicing", "place", "manner"],

    # What order are the axes? x = 0, y = 1, z = 2
    "axis order":  ["place", "manner", "voicing"]
}

# IPA chart glyphs (specifies the contents)
# Consider defining each phoneme on its own in the following way:
# t = {
#   "glyph" : "t" # None if not allowed to be selected / unsupported
#   "manner" : "plosive"
#   "place": "alveolar"
#   "voice": "unvoiced"
#   "possible": True # False if should be greyed out
# }
# and then using these definitions to fill in the IPA chart, instead of hardcoding
# This will be 22 data entries per row though.
# Might be worth it in the long run, because it will save the trouble of having
# to hardcode metaclasses -- e.g,
# labials = [c.get("glyph") in consonants if c.get("place") in ["bilabial", "labiodental"]]




# ================= JSON processing ===================
# Get Consonant info from consonants.json
# Consonants.json is generated by gen/ipa-json.js from gen/ipa-consonats.html
data = ipa_json.readIPAFromJson("phonemes/consonants.json")
#print(data)

# Extract glyphs from json
GLYPHS = utils.glyphs(data)

# Create dicts mapping all possible property values to the glyphs satisfying
# those properties
# E.g. {"voiced":    ["b", "d", ...],
#       "voiceless": ["p", "t", ...]}"""
MANNER_DICT = utils.enumerateProperty(data, "manner")
PLACE_DICT = utils.enumerateProperty(data, "place")
VOICING_DICT = utils.enumerateProperty(data, "voicing")

# Combine these dicts together
CLASSES_DICT = {**MANNER_DICT, **PLACE_DICT, **VOICING_DICT}
# print(CLASSES_DICT)



# =============== API functions ==================
def isConsonant(s):
    """Return True iff s is a consonant representable in this system"""
    return s in GLYPHS

def getGlyphsFromClass(className):
    return utils.getGlyphsFromClass(data, CLASSES_DICT, className)

def getGlyphsFromClasses(classList):
    return utils.getGlyphsFromClasses(data, CLASSES_DICT, classList)

def getGlyphsMatching(propertyName, propertyValue):
    """Finds a list of all phonemes from data such that the phoneme's
    property named propertyName has the value specified by propertyValue. Return
    a list of the glyphs of all matching phonemes"""
    return utils.getGlyphsMatching(data, propertyName, propertyValue)

def getNumMannersFromGlyphs(glyphList):
    """Finds the number of manners of articulation represented in glyphList"""
    phonemes = [utils.getDataFromGlyph(data, g) for g in glyphList]
    matches = utils.enumerateProperty(phonemes, "manner")
    return len(matches)

def getNumPlacesFromGlyphs(glyphList):
    """Finds the number of places of articulation represented in glyphList"""
    phonemes = [utils.getDataFromGlyph(data, g) for g in glyphList]
    matches = utils.enumerateProperty(phonemes, "place")
    return len(matches)
