from . import ipa_json, utils

# Canonical Consonant Order v2.0
# Be sure to check carefully before & after changing this list, as it may have
# unintended consequences, and is used throughout the program in various places
# as the authoritative, canonical list of phonemes.

# (Some) Areas this list affects:
# Generating the clickable phoneme selector GUI elements
# Checking for phoneme membership in language.py



# IPA chart glyphs (specifies the contents)
# Consider defining each phoneme on its own in the following way:
# t = {
#   "glyph" : "t" # None if not allowed to be selected / unsupported
#   "manner" : "plosive"
#   "place": "alveolar"
#   "voice": "unvoiced"
#   "possible": True # False if should be greyed out
# }
# and then using these definitions to fill in the IPA chart, instead of hardcoding
# This will be 22 data entries per row though.
# Might be worth it in the long run, because it will save the trouble of having
# to hardcode metaclasses -- e.g,
# labials = [c.get("glyph") in consonants if c.get("place") in ["bilabial", "labiodental"]]




# ================= JSON processing ===================
# Get Consonant info from consonants.json
# Consonants.json is generated by gen/ipa-json.js from gen/ipa-consonats.html
data = ipa_json.readIPAFromJson("phonemes/consonants.json")
#print(data)

# Extract glyphs from json
GLYPHS = utils.glyphs(data)

# Create dicts mapping all possible property values to the glyphs satisfying
# those properties
# E.g. {"voiced":    ["b", "d", ...],
#       "voiceless": ["p", "t", ...]}"""
MANNER_DICT = utils.enumerateProperty(data, "manner")
PLACE_DICT = utils.enumerateProperty(data, "place")
VOICING_DICT = utils.enumerateProperty(data, "voicing")

# Combine these dicts together
CLASSES_DICT = {**MANNER_DICT, **PLACE_DICT, **VOICING_DICT}
# print(CLASSES_DICT)


# =============== API functions ==================
def isConsonant(s):
    """Return True iff s is a consonant representable in this system"""
    return s in GLYPHS

#TODO unify these two functions with the identical ones in the accompanying vowel/consanant file
def getGlyphListFromClass(className):
    # If this is a special bypass class ("Any...") return all ones
    # else If natural class not recognized, return a string of all zeroes
    className = className.lower()
    if "Any ".lower() in className:
        return GLYPHS.copy()
    elif className not in CLASSES:
        raise ValueError("Class " + className + " not recognized as a natural class")
        return []

    classList = CLASSES[className]

    # Otherwise return a copy of the glyphlist for this class
    return classList.copy()

def getGlyphListFromClasses(classList):
    glyphSet = set([])
    for i, natClass in enumerate(classList):
        if i == 0:
            glyphList = getGlyphListFromClass(natClass)
            glyphSet = set(glyphList)
        else:
            glyphList = getGlyphListFromClass(natClass)
            glyphSet = set(glyphList).intersection(glyphSet)
    return list(glyphSet)

def getGlyphsMatching(propertyName, propertyValue):
    """Finds a list of all phonemes from data such that the phoneme's
    property named propertyName has the value specified by propertyValue. Return
    a list of the glyphs of all matching phonemes"""
    return utils.getGlyphsMatching(data, propertyName, propertyValue)
